# The vanilla client in getting started

In this tutorial you learn how [the vanilla client of the minimal example](https://github.com/latticexyz/mud/tree/main/templates/vanilla) works.
This client is in many ways the lowest common denominator, because it does not require knowledge of any UI libraries beyond HTML and JavaScript.

## `index.html`

[This file](https://github.com/latticexyz/mud/blob/main/templates/vanilla/packages/client/index.html) is the entry point and the code shown to the user.

<details>

<summary>Line-by-line explanation</summary>

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>a minimal MUD client</title>
  </head>
</html>
```

This is a standard boilerplate [HTML header](https://www.w3schools.com/html/html_head.asp).

```html
<body>
  <script type="module" src="/src/index.ts"></script>
</body>
```

This [`script` tag](https://www.w3schools.com/html/html_scripts.asp) executes [the main script for the application](#srcindexts).

```html
<div>
  <div>Counter: <span id="counter">0</span></div>
</div>
```

This [`span` tag](https://www.w3schools.com/tags/tag_span.asp) creates a span called `counter`, whose value can then be updated from the JavaScript code.

```html
      <button onclick="window.increment()">Increment</button>
    </div>
```

This button calls the function defined in [`src/index.ts`](#srcindexts).

```html
  </body>
</html>
```

Standard end of HTML tags.

</details>

## `src/index.ts`

[This file](https://github.com/latticexyz/mud/blob/main/templates/vanilla/packages/client/src/index.ts) is the main script of the application, imported from [`index.html`](#indexhtml).
The script is written in [TypeScript](https://www.typescriptlang.org/), which is then translated into JavaScript by [vite](https://vitejs.dev/), the package we use as a web server.

<details>

<summary>Line-by-line explanation</summary>

```typescript
import { mount as mountDevTools } from "@latticexyz/dev-tools";
```

We are getting the `mount` function from [`@latticexyz/dev-tools`](https://www.npmjs.com/package/@latticexyz/dev-tools), an NPM package.
This function creates the area on the right of the browser window that includes information about MUD.

```typescript
import { setup } from "./mud/setup";
```

The code generated by mud is located in [the `src/mud` directory](https://github.com/latticexyz/mud/tree/main/templates/vanilla/packages/client/src/mud).
The main setup code resides in [`src/mud/setup.ts`](#srcmudsetupts).
The function to call in that file is `setup`.

```typescript
const {
  components,
  systemCalls: { increment },
} = await setup();
```

Run `setup()` (and wait for it to finish).
Afterwards, get `components` and `systemCalls.increment` from the result.

```typescript
// Components expose a stream that triggers when the component is updated.
components.CounterTable.update$.subscribe((update) => {
```

When `CounterTable` is updated, run the function in the parameter.

```typescript
const [nextValue, prevValue] = update.value;
```

Read the update.
Note that the update includes both the new value and the previous one.

```typescript
console.log("Counter updated", update, { nextValue, prevValue });
document.getElementById("counter")!.innerHTML = String(nextValue?.value ?? "unset");
```

Update the `counter` area [in the HTML](#indexhtml).
The syntax is a bit complicated, because of the way TypeScript works.

`document.getElementById("counter")` can return either an HTML element (if there is one called `counter`) or nothing.
The exclamation point (`!`) tells TypeScript to trust us that it does exist and have an `innerHTML` field.

```typescript
});

// Just for demonstration purposes: we create a global function that can be
// called to invoke the Increment system contract via the world. (See IncrementSystem.sol.)
(window as any).increment = async () => {
  console.log("new counter value:", await increment());
};
```

Make the `increment` function available by adding it to [the `window` global variable](https://www.w3schools.com/js/js_window.asp).
Note the syntax `window as any`.
The `window` variable can have various fields added to it, so it cannot be fully defined in TypeScript.
The `as any` tells TypeScript not to worry about the type definition in this case, and just assume that the code is correct.

The value is incremented by `await increment()`, which is defined in `(await setup()).systemCalls`.

```typescript
mountDevTools();
```

Finally, `mountDevTools` creates the right bar with the MUD information.

</details>

## `src/mud/setup.ts`

[This file](https://github.com/latticexyz/mud/blob/main/examples/minimal/packages/client-vanilla/src/mud/setup.ts) sets up all the definitions required for a mud client.

<details>

<summary>Line-by-line explanation</summary>

```ts
import { createClientComponents } from "./createClientComponents";
import { createSystemCalls } from "./createSystemCalls";
import { setupNetwork } from "./setupNetwork";
```

Import the code that does various types of setup.

```ts
export type SetupResult = Awaited<ReturnType<typeof setup>>;
```

The type definition for the return type of `setup`.

```ts
export async function setup() {
```

This is the `setup` function that is called from [`src/index.ts`](https://github.com/latticexyz/mud/blob/main/examples/minimal/packages/client-vanilla/src/index.ts).

```ts
const network = await setupNetwork();
const components = createClientComponents(network);
const systemCalls = createSystemCalls(network, components);
```

Get the network information, the components, and the system calls from the imported code.

```ts
  return {
    network,
    components,
    systemCalls,
  };
}
```

Return all of this information.
This structure's syntax is shorthand for:

```ts
{
  "network": network,
  "components": components,
  "systemCalls": systemCalls
}
```

</details>

## ``

<details>

<summary>Line-by-line explanation</summary>

```typescript

```

</details>

## `src/mud/getNetworkConfig.ts`

[This file](https://github.com/latticexyz/mud/blob/main/examples/minimal/packages/client-vanilla/src/mud/getNetworkConfig.ts) gets the network configuration for accessing [the onchain code](./minimal-onchain).

```ts
import { SetupContractConfig, getBurnerWallet } from "@latticexyz/std-client";
import worldsJson from "contracts/worlds.json";
import { supportedChains } from "./supportedChains";

const worlds = worldsJson as Partial<Record<string, { address: string; blockNumber?: number }>>;

type NetworkConfig = SetupContractConfig & {
  privateKey: string;
  faucetServiceUrl?: string;
  snapSync?: boolean;
};

export async function getNetworkConfig(): Promise<NetworkConfig> {
  const params = new URLSearchParams(window.location.search);

  const chainId = Number(params.get("chainId") || import.meta.env.VITE_CHAIN_ID || 31337);
  const chainIndex = supportedChains.findIndex((c) => c.id === chainId);
  const chain = supportedChains[chainIndex];
  if (!chain) {
    throw new Error(`Chain ${chainId} not found`);
  }

  const world = worlds[chain.id.toString()];
  const worldAddress = params.get("worldAddress") || world?.address;
  if (!worldAddress) {
    throw new Error(`No world address found for chain ${chainId}. Did you run \`mud deploy\`?`);
  }

  const initialBlockNumber = params.has("initialBlockNumber")
    ? Number(params.get("initialBlockNumber"))
    : world?.blockNumber ?? -1; // -1 will attempt to find the block number from RPC

  return {
    clock: {
      period: 1000,
      initialTime: 0,
      syncInterval: 5000,
    },
    provider: {
      chainId,
      jsonRpcUrl: params.get("rpc") ?? chain.rpcUrls.default.http[0],
      wsRpcUrl: params.get("wsRpc") ?? chain.rpcUrls.default.webSocket?.[0],
    },
    privateKey: getBurnerWallet().value,
    chainId,
    modeUrl: params.get("mode") ?? chain.modeUrl,
    faucetServiceUrl: params.get("faucet") ?? chain.faucetUrl,
    worldAddress,
    initialBlockNumber,
    snapSync: params.get("snapSync") === "true",
    disableCache: params.get("cache") === "false",
  };
}
```

## `src/mud/setupNetwork.ts`

[This file](https://github.com/latticexyz/mud/blob/main/examples/minimal/packages/client-vanilla/src/mud/setupNetwork.ts) contains the code to get the network information.

```ts
import { setupMUDV2Network } from "@latticexyz/std-client";
import { createFastTxExecutor, createFaucetService, getSnapSyncRecords } from "@latticexyz/network";
```

Import various files from the `@latticexyz` packages.

```ts
import { getNetworkConfig } from "./getNetworkConfig";
import { defineContractComponents } from "./contractComponents";
import { world } from "./world";
import { Contract, Signer, utils } from "ethers";
import { JsonRpcProvider } from "@ethersproject/providers";
import { IWorld__factory } from "contracts/types/ethers-contracts/factories/IWorld__factory";
import { getTableIds } from "@latticexyz/utils";
import storeConfig from "contracts/mud.config";

export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;

export async function setupNetwork() {
  const contractComponents = defineContractComponents(world);
  const networkConfig = await getNetworkConfig();
  const result = await setupMUDV2Network<typeof contractComponents, typeof storeConfig>({
    networkConfig,
    world,
    contractComponents,
    syncThread: "main",
    storeConfig,
    worldAbi: IWorld__factory.abi,
  });

  // Request drip from faucet
  const signer = result.network.signer.get();
  if (networkConfig.faucetServiceUrl && signer) {
    const address = await signer.getAddress();
    console.info("[Dev Faucet]: Player address -> ", address);

    const faucet = createFaucetService(networkConfig.faucetServiceUrl);

    const requestDrip = async () => {
      const balance = await signer.getBalance();
      console.info(`[Dev Faucet]: Player balance -> ${balance}`);
      const lowBalance = balance?.lte(utils.parseEther("1"));
      if (lowBalance) {
        console.info("[Dev Faucet]: Balance is low, dripping funds to player");
        // Double drip
        await faucet.dripDev({ address });
        await faucet.dripDev({ address });
      }
    };

    requestDrip();
    // Request a drip every 20 seconds
    setInterval(requestDrip, 20000);
  }

  const provider = result.network.providers.get().json;
  const signerOrProvider = signer ?? provider;
  // Create a World contract instance
  const worldContract = IWorld__factory.connect(networkConfig.worldAddress, signerOrProvider);

  if (networkConfig.snapSync) {
    const currentBlockNumber = await provider.getBlockNumber();
    const tableRecords = await getSnapSyncRecords(
      networkConfig.worldAddress,
      getTableIds(storeConfig),
      currentBlockNumber,
      signerOrProvider
    );

    console.log(`Syncing ${tableRecords.length} records`);
    result.startSync(tableRecords, currentBlockNumber);
  } else {
    result.startSync();
  }

  // Create a fast tx executor
  const fastTxExecutor =
    signer?.provider instanceof JsonRpcProvider
      ? await createFastTxExecutor(signer as Signer & { provider: JsonRpcProvider })
      : null;

  // TODO: infer this from fastTxExecute signature?
  type BoundFastTxExecuteFn<C extends Contract> = <F extends keyof C>(
    func: F,
    args: Parameters<C[F]>,
    options?: {
      retryCount?: number;
    }
  ) => Promise<ReturnType<C[F]>>;

  function bindFastTxExecute<C extends Contract>(contract: C): BoundFastTxExecuteFn<C> {
    return async function (...args) {
      if (!fastTxExecutor) {
        throw new Error("no signer");
      }
      const { tx } = await fastTxExecutor.fastTxExecute(contract, ...args);
      return await tx;
    };
  }

  return {
    ...result,
    worldContract,
    worldSend: bindFastTxExecute(worldContract),
    fastTxExecutor,
  };
}
```
